# Формальные языки

# Задание

- По заданному регулярному выражению в обратной польской нотации и входному слову найти длину найбольшего префикса входящего в язык задаваемый регулярным выражением. 

## Описание алгоритма

- Алгоритм построен на методе производных Бржозовского, суть которого неформально - посимвольное сокращение исходного регулярного выражения, до тех пор, пока не получим тривиальное выражение. Этот алгоритм позволяет напрямую без построения НКА, строить ДКА (Но в решении не используется построение ДКА).

## Формальные определения

Производной языка $L$ по слову $u \in \Sigma*$ есть язык - $\partial_u L = \lbrace v \mid u \cdot v \in L \rbrace$.

Для произвольных символов $a$ и $b$, а так же для произвольных регулярных выражений $r$ и $s$ зададим следующие правила:

$$
\begin{align}
\partial_a \varepsilon &= \emptyset & \\
\partial_a a &= \epsilon & \\
\partial_a b &= \emptyset & \text{ for }(a \neq b) \\
\partial_a (r \cdot s) &= \partial_a r \mid ContainsEps(r) \cdot \partial_a s & \\
\partial_a (r \mid s) &= \partial_a r \mid \partial_a s & \\
\partial_a (r*) &= \partial_a r \cdot r* &
\end{align}
$$

где функция $ContainsEps(r)$ проверяет на наличие пустого слова в языке.
Зададим следующие рекурсивные правила для $ContainsEps$:

$$
\begin{align}
ContainsEps(\varepsilon) &= \varepsilon \\
ContainsEps(\emptyset) &= \emptyset \\
ContainsEps(a) &= \emptyset \\
ContainsEps(r \cdot s) &= ContainsEps(r) \cdot ContainsEps(s) \\
ContainsEps(r \mid s) &= ContainsEps(r) \mid ContainsEps(s) \\
ContainsEps(r*) &= \varepsilon
\end{align}
$$

Так же последние два важных правила:

$$
\begin{align}
\partial_\varepsilon r &= r \\
\partial_{ua} &= \partial_{a} \partial_{u} r
\end{align}
$$

Таким образом, для вычисления производной языка по данному слову, нужно проделать это побуквенно, а так же для проверки принадлежности слова языку нужно проверить следующее условие:

$$
ContainsEps(\partial_{u} r) = \varepsilon
$$

поскольку мы каждый раз "откусываем" от регулярного выражения по букве, и в конце, если слово принадлежит языку, производная будет содержать пустое слово, иначе слово не принадлежит языку (в аналогии с ПДКА, слово либл приходит в завершающее состояние, либо зацикливается в "стоке").

## Запуск программы и тестов

```
> g++ main.cpp -o main
> ./main <регулярное_выражение> <входное_слово>

```

```
> g++ test.cpp -o test
> ./test

```

## Пример запуска

```
> ./main
a*b*. aaabbc // Input
5 // Output

```

## Оценка времени работы

- Пусть m длина регулярного выражения, n - длина входного слова.

- Алгоритм по входному регулярному выражению строит синтаксическое дерево разбора, высота которго есть _O(logm)_. При обработке самого слова идем по убыванию длины n, при этом вызываемся так же не более n раз. Итоговая оценка _O(n*n*logm)_

## Источники

youtube.com: https://www.youtube.com/watch?v=s9EPoy9r-ok

neerc.ifmo.ru: https://clck.ru/LmPWH (сокращенная ссылка)

google.com

